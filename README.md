# Heroes Student Task

В этом репозитории реализованы 4 ключевых алгоритма для проекта **Heroes Battle**:

- `GeneratePreset.generate(...)` — генерация армии компьютера
- `SimulateBattle.simulate(...)` — симуляция боя по раундам
- `SuitableForAttackUnitsFinder.getSuitableUnits(...)` — отбор целей, доступных для атаки
- `UnitTargetPathFinder.getTargetPath(...)` — поиск кратчайшего пути на поле (с препятствиями)

> Готовый JAR лежит в `release/heroes-student-task.jar`.

---

## Как проверить в игре

1. Распакуйте архив с игрой (путь **без кириллицы**).
2. Скопируйте `release/heroes-student-task.jar` в папку `heroes/jars/`, **заменив** лежащий там `obf.jar`.
3. Запустите игру и проверьте:
   - генерацию пресета армии компьютера
   - запуск боя и корректное логирование ходов

---

## Сборка JAR

Проект не требует Gradle для сборки JAR с реализациями (достаточно `javac` + `jar`).

### Через IntelliJ IDEA
`Build -> Build Artifacts -> JAR`

### Через консоль
```bash
javac -encoding UTF-8 -cp libs/heroes_task_lib-1.0-SNAPSHOT.jar -d out $(find src -name "*.java")
jar cf heroes-student-task.jar -C out .
```

---

# Реализованные алгоритмы и сложность

## 1) GeneratePresetImpl.generate(List<Unit> unitList, int maxPoints)

**Цель:** собрать армию компьютера с ограничениями:
- суммарная стоимость `<= maxPoints`
- каждого типа `<= 11`
- приоритет эффективности: сначала `атака/стоимость`, при равенстве — `здоровье/стоимость`

**Алгоритм (жадный):**
1. Для каждого типа считаются коэффициенты:
   - `atkScore = baseAttack / cost`
   - `hpScore = health / cost`
2. Типы сортируются по убыванию `atkScore`, затем по убыванию `hpScore`.
3. По отсортированным типам “покупаются” юниты, пока хватает очков и не превышен лимит `11` на тип.
4. Остаток очков добивается юнитами типа с максимальным `hpScore` (если не нарушает лимит).

**Размещение на поле:** юниты расставляются в зоне компьютера `x = 0..2`, `y = 0..20` без пересечений.

**Сложность:**
- расчёт коэффициентов по типам: `O(n)`
- сортировка типов: `O(n log n)`
- добавление до `m` юнитов: `O(m)`
- размещение: `O(m)`

Итог: **`O(n log n + m)`**, что лучше требуемого `O(n·m)`.

---

## 2) SimulateBattleImpl.simulate(Army playerArmy, Army computerArmy)

**Цель:** провести бой раундами по правилам:
- в начале каждого раунда формируется очередь из **всех живых** юнитов
- очередь сортируется по убыванию `baseAttack`
- каждый живой юнит делает попытку атаки через `unit.getProgram().attack()`
- после атаки печатается лог `printBattleLog.printBattleLog(attacker, target)`
- мёртвые юниты не получают ходов (через проверку `isAlive`)

**Ключевой приём:** “ленивая фильтрация” мёртвых — вместо удаления из списка (дорогая операция), просто проверяем `isAlive` перед ходом.

**Критерий завершения:** бой останавливается, когда в раунде одна из армий не смогла совершить ни одной атаки (нет “способных сделать ход” юнитов), либо когда у одной из армий не осталось живых.

**Сложность:**
Пусть `N` — общее число юнитов (обе армии).
- на раунд: построение очереди `O(N)` + сортировка `O(N log N)` + проход `O(N)`  
  => `O(N log N)` на раунд
- в худшем случае число раундов `R = O(N)`  
  => **`O(N^2 log N)`** (как и требуется при `attack() = O(1)`)

---

## 3) SuitableForAttackUnitsFinderImpl.getSuitableUnits(...)

**Цель:** вернуть список целей, доступных для атаки, по 3 “рядам”.

**Алгоритм:**
- в каждом ряду выбирается только “передний” юнит:
  - если атакуем **левую** армию (`isLeftArmyTarget = true`) — берём юнита с **максимальным `x`**
  - если атакуем **правую** армию (`isLeftArmyTarget = false`) — берём юнита с **минимальным `x`**
- если в ряду нет живых — ряд пропускается

**Сложность:** проход по всем юнитам в 3 рядах — **`O(N)`**.

---

## 4) UnitTargetPathFinderImpl.getTargetPath(...)

**Цель:** найти кратчайший путь на поле `27x21` с препятствиями (клетки, занятые живыми юнитами).  
Если путь недоступен — вернуть пустой список.

**Алгоритм:** **A\*** (A-star) по сетке в 8 направлений (включая диагонали).
- стоимость шага = `1` (включая диагональ)
- эвристика: расстояние Чебышёва `h = max(|dx|,|dy|)`

**Сложность:**
- `V = W·H`, `E ≈ 8V`
- A\* с priority queue: `O(E log V) ≈ O(V log V)`  
Итог: **`O((W·H) log(W·H))`**, соответствует требованию.

---
